
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <!-- <link type="text/css" rel="stylesheet" href="style.css"/> -->
    <script type="text/javascript" src="d3.js"></script>
    <script type="text/javascript" src="d3.layout.js"></script>
    <script type="text/javascript" src="colorbrewer.js"></script>
    <script type="text/javascript" src="underscore.js"></script>
    <style type="text/css">

      body {
        background: #222;
        font-family: sans-serif;
      }
      .node circle {
        cursor: pointer;
        /*fill: #fff;*/
        stroke: steel ;
        stroke-width: 1.5px;
      }

      .node text {
        font-size: 16px;
      }

      path.link {
        fill: none;
        stroke: #666;
        stroke-width: 1.5px;
      }

      svg {
        margin: 0px auto;
        display: block;
      }

      rect.nodeHover {
        fill: "aliceblue";
      }

    </style>
  </head>
  <body>
      <div id="body">
      </div>

      <!-- JAVASCRIPT -->
      <script type="text/javascript">
        var m = [100, 120, 20, 120],
            w = 960 - m[1] - m[3],
            h = 800 - m[0] - m[2],
            i = 0,
            root;

        var tree = d3.layout.tree()
            .size([h, w]);

        var diagonal = d3.svg.diagonal()
            .projection(function(d) { return [d.y, d.x]; });

        var vis = d3.select("#body").append("svg:svg")
            .attr("width", w + m[1] + m[3])
            .attr("height", 4000)
          .append("svg:g")
            .attr("transform", "translate(" + m[3] + "," + m[0] + ")");

        var o = d3.scale.ordinal()
          .domain([0,0.001])
          .range(colorbrewer.YlOrRd[6].reverse());

        var o2 = d3.scale.ordinal()
          .domain([0.1,0.2,0.8])
          .range(colorbrewer.OrRd[3]);

        var cell_ht = 50
        var topmargin = 20

        drawMap = function(map, topmargin) {
          map.enter().append('svg:rect')
            .attr('class', 'cell')
            .attr('x', function(d) { return(d[1]*cell_ht)})
            .attr('y', function(d) { return(d[0]*cell_ht+topmargin)})
            .attr("width", cell_ht)
            .attr("height", cell_ht)
            .attr('stroke','#333')
            .attr('fill', function(d) {
              if (d[2] == 99) {
                return('grey')
              } else {
                return('black')
              }
            })
        }

        d3.json('path.json', function(json) {
          var robot = vis.selectAll('circle').data([json[0]]);
          
          vis.append("svg:text")
              .text('Autonomous Robot Navigation')
              .style('font-size', '36px')
              .style('fill', 'white')
              .style("fill-opacity", 1);

          d3.json('transitions_matrix.json', function(transitions) {
            d3.json('map.json', function(map) {

              vis.append("svg:text")
                  .text('We start with a simplified office map.')
                  .attr('x', cell_ht*4+20)
                  .attr('y', topmargin+16)
                  .style('font-size', '16px')
                  .style('fill', 'white');

              var map = vis.selectAll('rect.cell').data(map)

              // original map
              drawMap(map, topmargin)

              topmargin = 4*cell_ht + topmargin + 40

              // map with optimum path
              drawMap(map, topmargin)

              map.enter().append('svg:text')
                .attr('class', 'cell')
                .attr('x', function(d) { return(d[1]*cell_ht + cell_ht/2-4)})
                .attr('y', function(d) { return(d[0]*cell_ht+topmargin + cell_ht/2+5)})
                .attr('fill', 'white')
                .text(function(d) { if (d[2] != 99) { return(d[2])}})

              vis.append("svg:text")
                  .text('We give the robot a set of instructions to move in direction of "least cost".')
                  .attr('x', cell_ht*4+20)
                  .attr('y', topmargin+16)
                  .style('font-size', '16px')
                  .style('fill', 'white');

              topmargin = 4*cell_ht + topmargin + 40

              // map with transitions
              map.enter().append('svg:rect')
                .attr('class', 'cell')
                .attr('x', function(d) { return(d[1]*cell_ht)})
                .attr('y', function(d) { return(d[0]*cell_ht+topmargin)})
                .attr("width", cell_ht)
                .attr("height", cell_ht)
                .attr('stroke','#333')
                .attr('fill', function(d) {
                  if (d[2] == 99) {
                    return('grey')
                  } else {
                    return('black')
                  }
                })              
                .on('mouseout', function(d) {
                   d3.selectAll('.tempcell').remove()
                   d3.selectAll('.temptext').remove()
                   d3.select(this).attr('fill',function(d) {
                      if (d[2] == 99) {
                        return('grey')
                      } else {
                        return('black')
                      }                    
                    }).style('opacity',1)
                })
                .on('mouseover', function(d) {
                  d3.select(this)
                    .attr('fill','grey')
                    .style('opacity',0.2)
                  var loc = '(' + d[0]+', '+d[1]
                  var keys_for_cell = _.filter(_.keys(transitions), function(key){
                     return key.indexOf(loc) > -1
                  });

                  // now list all the possible transitions
                  keys_for_cell.forEach(function(k) {
                    good_transitions = _.pick(transitions[k], function(value, key, object) {
                      return value > 0.0;
                    });
                    
                    // for every possible transition, highlight the cell
                    _.keys(good_transitions).forEach(function(key) {
                      positions = _.map(key.replace('(','').replace(')','').split(', '), function(n) {return parseInt(n)})
                      x = positions[1]
                      y = positions[0]

                      map.enter().append('svg:rect')
                        .attr('class', 'tempcell')
                        .attr('x', x*cell_ht)
                        .attr('y', y*cell_ht+topmargin)
                        .attr("width", cell_ht)
                        .attr("height", cell_ht)
                        .attr('fill', o2(good_transitions[key]))
                        .attr('opacity',0.1)
                      
                      if (d3.selectAll('.temptext')[0].length == 0) {
                        _.values(good_transitions).forEach(function(prob,i) {
                          vis.append("svg:text")
                            .attr('class','temptext')
                            .text(prob)
                            .attr('x', cell_ht*4+20)
                            .attr('y', topmargin+66+i*22)
                            .style('font-size', '16px')
                            .style('fill', 'white');   
                        })        
                      }           
                    })
                  })
                });

                vis.append("svg:text")
                  .text('We have a probabilistic belief about what steps the robot may take.')
                  .attr('x', cell_ht*4+20)
                  .attr('y', topmargin+16)
                  .style('font-size', '16px')
                  .style('fill', 'white');

                vis.append("svg:text")
                  .text('Hover over a cell to see what transitions are most likely.')
                  .attr('x', cell_ht*4+20)
                  .attr('y', topmargin+38)
                  .style('font-size', '16px')
                  .style('fill', 'white');

                map.enter().append('svg:rect')
                  .attr('class', 'cell')
                  .attr('x', function(d) { return(d[1]*cell_ht)})
                  .attr('y', function(d) { return(d[0]*cell_ht + 4*cell_ht + topmargin + 40)})
                  .attr("width", cell_ht)
                  .attr("height", cell_ht)
                  .attr('stroke','#333')
                  .attr('fill', function(d) {
                    if (d[2] == 99) {
                      return('grey')
                    } else if (d[2] == 0) {
                      return('limegreen')
                    } else {
                      return(colorbrewer.OrRd[9][9-d[2]])
                    }
                  });

                vis.append("svg:text")
                  .text('So when we are given a set of steps: "(down, right, down, ...)",')
                  .attr('x', cell_ht*4+20)
                  .attr('y', 4*cell_ht + topmargin + 40 + 16)
                  .style('font-size', '16px')
                  .style('fill', 'white');

                vis.append("svg:text")
                  .text('we can reconstruct the most likely path. (Click the circle)')
                  .attr('x', cell_ht*4+20)
                  .attr('y', 4*cell_ht + topmargin + 40 + 38)
                  .style('font-size', '16px')
                  .style('fill', 'white');

                robot.enter()
                    .append("svg:circle")
                    .attr('class','robot')
                    .attr("r", 6)
                    .attr('cx', function(d) {return d[1] + cell_ht/2})
                    .attr('cy', function(d) {return d[0] + cell_ht/2 + 4*cell_ht + topmargin + 40})
                    .style("fill", 'lime')
                    .style('stroke', 'green')
                    .on('click', function() {
                      json.forEach(function(move,idx) {
                        vis.selectAll('.robot').transition()
                          .delay(1000*idx)
                          .duration(1000)
                          .ease('linear')
                          .attr('cx', move[1]*cell_ht + cell_ht/2)
                          .attr('cy', move[0]*cell_ht + cell_ht/2 + 4*cell_ht + topmargin + 40)
                      })
                    })
            })
          })
        });

        
        var speech_group = vis.append("svg:g").attr('id','speech_group')
            .attr("transform", "translate(" + 0 + "," + 1000 + ")");

        var trellis_diagram = speech_group.append("svg:g").attr('id','trellis_diagram')
            .attr("transform", "translate(" + 0 + "," + 30 + ")");

        speech_group.append("svg:text")
                    .text('Speech Recognition')
                    .style('font-size','36px')
                    .style('fill', 'white')
                    .style("fill-opacity", 1);

        speech_group.append("svg:text")
                    .text('phone 1: n')
                    .style('font-size','18px')
                    .attr('y', 50)
                    .attr('x', 102)
                    .style('fill', 'white')
                    .style("fill-opacity", 1);

        speech_group.append("svg:text")
                    .text('2: iy')
                    .style('font-size','18px')
                    .attr('y', 50)
                    .attr('x', 270)
                    .style('fill', 'white')
                    .style("fill-opacity", 1);

        speech_group.append("svg:text")
                    .text('3: t')
                    .style('font-size','18px')
                    .attr('y', 50)
                    .attr('x', 450)
                    .style('fill', 'white')
                    .style("fill-opacity", 1);

        d3.json("dict.json", function(json) {
          root = json;
          root.x0 = h / 2;
          root.y0 = 0;
          function toggleAll(d) {
            if (d.children) {
              d.children.forEach(toggleAll);
              toggle(d);
            }
          }

          // Initialize the display to show a few nodes.
          root.children.forEach(toggleAll);

          update(root);
        });

        function update(source) {
          var duration = d3.event && d3.event.altKey ? 5000 : 500;

          // Compute the new tree layout.
          var nodes = tree.nodes(root).reverse();

          // Normalize for fixed-depth.
          nodes.forEach(function(d) { d.y = d.depth * 180; });

          // Update the nodes…
          var node = trellis_diagram.selectAll("g.node")
              .data(nodes, function(d) { return d.id || (d.id = ++i); });

          // Enter any new nodes at the parent's previous position.
          var nodeEnter = node.enter().append("svg:g")
              .attr("class", "node")
              .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
              .on("click", function(d) { 
                toggle(d);
                update(d); });

          nodeEnter.append("svg:circle")
              .attr("r", 1e-6)
              .style("fill", function(d) {
                if (d.value == 0.0) {
                  return 'white'
                } else {
                  return o(d.value)
                };
              });

          nodeEnter.append("svg:text")
              .attr("x", -10)//function(d) { return d.children || d._children ? -10 : 10; })
              .attr("dy", ".35em")
              .attr("text-anchor", "end")//function(d) { return d.children || d._children ? "end" : "start"; })
              .text(function(d) { return d.name; })
              .style('fill', 'white')
              .style("fill-opacity", 1e-6);

          // Transition nodes to their new position.
          var nodeUpdate = node.transition()
              .duration(duration)
              .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

          nodeUpdate.select("circle")
              .attr("r", 4.5)

          nodeUpdate.select("text")
              .style("fill-opacity", 1);

          // Transition exiting nodes to the parent's new position.
          var nodeExit = node.exit().transition()
              .duration(duration)
              .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
              .remove();

          nodeExit.select("circle")
              .attr("r", 1e-6);

          nodeExit.select("text")
              .style("fill-opacity", 1e-6);

          // Update the links…
          var link = trellis_diagram.selectAll("path.link")
              .data(tree.links(nodes), function(d) { return d.target.id; });

          // Enter any new links at the parent's previous position.
          link.enter().insert("svg:path", "g")
              .attr("class", "link")
              .attr("d", function(d) {
                var o = {x: source.x0, y: source.y0};
                return diagonal({source: o, target: o});
              })
            .transition()
              .duration(duration)
              .attr("d", diagonal);

          // Transition links to their new position.
          link.transition()
              .duration(duration)
              .attr("d", diagonal);

          // Transition exiting nodes to the parent's new position.
          link.exit().transition()
              .duration(duration)
              .attr("d", function(d) {
                var o = {x: source.x, y: source.y};
                return diagonal({source: o, target: o});
              })
              .remove();

          // Stash the old positions for transition.
          nodes.forEach(function(d) {
            d.x0 = d.x;
            d.y0 = d.y;
          });
        }

        // Toggle children.
        function toggle(d) {
          if (d.children) {
            d._children = d.children;
            d.children = null;
          } else {
            d.children = d._children;
            d._children = null;
          }
        }

      </script>
  </body>
</html>
